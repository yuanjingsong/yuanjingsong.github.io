<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oath</title>
  
  <subtitle>教练，我想学编程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuanjngsong.github.io/"/>
  <updated>2018-11-12T11:43:10.993Z</updated>
  <id>http://yuanjngsong.github.io/</id>
  
  <author>
    <name>yuanjngsong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PV 操作与同步问题</title>
    <link href="http://yuanjngsong.github.io/2018/10/11/pv%E6%93%8D%E4%BD%9C/"/>
    <id>http://yuanjngsong.github.io/2018/10/11/pv操作/</id>
    <published>2018-10-11T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>###问题引入<br>在操作系统的多线程中，如何保证多个线程都对数据操作的一致性是我们需要考虑的问题。数据的不一致性主要体现在</p><ul><li>不可重复读 两次读到的数据不一致</li><li>丢失修改 对数据进行操作之后，之后的数据又发生变化</li><li>读到脏数据 读到一个数据之后，该数据被改动</li></ul><p>所以，我们针对这些并发性问题，可以引入信号量(semphore)来协调进程之间的竞争关系。</p><p>信号量可以看作对一个资源的抽象描述，类型为整数类型，可以取负数，他描述了可用资源的数量。当信号量为负数时，其绝对值表示的是等待的进程数量。<br>对信号量的操作，我们只允许 P 操作和 V 操作，并且，这两个操作都是原子操作即他们两个不能互相中断对方。</p><h3 id="P-操作和-V-操作的实现"><a href="#P-操作和-V-操作的实现" class="headerlink" title="P 操作和 V 操作的实现"></a>P 操作和 V 操作的实现</h3><p>现在对 P 操作和 V 操作进行定义：<br>由于我们是对一个资源 S 进行操作，我们希望，如果 S 存在的时候，我们可以继续对数据进行操作，当 S 消耗完的时候，接下来对数据的操作无法进行，即进程被堵塞。我们可以把 S 看成对访问数据的一个保护，如果 S 存在，可以对数据操作，如果 S 消耗完，不能对数据进行操作。<br>所以，P 的逻辑可以定义为，如果 S 不存在，则等待，如果 S 存在，把 S 变小，即资源的值被消耗，然后对需要的数据进行访问。<br>同样的，V 的逻辑可以定义为，把 S 增大，即对资源的值释放。<br>可以得到这样的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(s): while (s &lt;= 0) wait;</span><br><span class="line">      s --;</span><br><span class="line">    </span><br><span class="line">V(s): s ++;</span><br></pre></td></tr></table></figure></p><p>但其实，这段代码存在忙等的现象，即当 s 为初始化为 0时，进入 p 操作，此时，进入等待状态，如果没有 v 操作，此时，这个线程陷入等待。而对 s 的占用和释放是一个线程应具备的两个对应的操作，根据逻辑上而言，一个线程不可能会先做对需要资源做释放，然后在做占用操作。所以，当另一个线程对 s 做操作时，也只能做 p 操作，不可能先出现 v 操作，即这个进入等待的线程出现自旋锁。</p><p>所以，代码应该成如下的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P(s): s --;</span><br><span class="line">    if s &lt; 0:</span><br><span class="line">        wait();</span><br><span class="line">V(s): s++;</span><br><span class="line">    if s &lt;= 0:</span><br><span class="line">        wakeup(wait_queue);</span><br></pre></td></tr></table></figure></p><p>这个时候，两个操作都是先对 s 进行操作，然后在判断 s 的值，决定是否堵塞进程还是唤醒进程。需要注意的是，堵塞进程和唤醒进程的条件是不一样的，在 p 操作时，当<code>s &lt; 0</code>的时候，才会堵塞进程，因为是先对 s 的值进行操作，所以，<code>s &lt; 0</code> 则之前必有 <code>s &lt;= 0</code> ,没有资源，自然应该进入等待队列。而在 v 操作时，当 <code>s &lt;= 0</code>的时候，我们进行唤醒操作，对 s 操作之前必有 s 的值为 <code>s &lt; 0</code> 说明有进程在等待队列，所以从等待队列中唤醒一个进程。</p><p>###读者和写者问题<br>读者和写者问题定义了数据库操作模型，他定义了一个问题场景，对于一组数据，有读者和写者两个角色，其中，读者可以读取数据，写者可以修改数据。在引入多线程之后，如何保证不会出现读到脏数据，不可重复读和丢失修改是我们应该考虑的问题。所以，我们应该对读者和写者之间作出互斥规定，避免出现这三类问题。</p><p>####第一类读者和写者问题（读者优先）<br>定义读者和写者之间的操作有以下的关系：</p><ol><li>当有读者在读时，其他读者也可以读</li><li>当有读者读时，其他写者不能写，当有写者在写时，其他读者不能读</li><li>一个写者在写时，其他写者不允许写</li><li>当读者在读时且写者在等待读者读时，后来的读者可以跳过等待的写者继续读</li></ol><p>这四条规则定义了第一类读者和写者问题，如何定义他们的操作来保证不会出现上述的三个问题是我们的任务。<br>这里，读者和写者是互斥关系，一个在读时，另一个不能写，一个在写时，另一个不能读，所以我们可以定义一个共同的信号量 <code>mutex</code> 控制他们互斥关系。写者之间也是互斥关系，但我们也可以使用 <code>mutex</code> 控制他们之间的互斥。读者之间允许同时读，所以，如果对读者也使用 <code>mutex</code> 控制的话， 会出现读者的互斥，所以，我们使用 <code>readingCount</code> 去控制 <code>mutex</code> , <code>readingCount</code> 表示读者的数量。但读者操作的时候需要对 <code>readingCount</code> 进行修改，这样在读者之间需要保证 <code>readingCount</code> 数量的同步，所以，需要设置信号量<br><code>enable_read</code> 控制读者对 <code>readingCount</code> 的修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Reader()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        p(enable_read);</span><br><span class="line">        readingCount ++;</span><br><span class="line">        if (readingCount == 1)</span><br><span class="line">            p(mutex);     </span><br><span class="line">        v(enable_read);</span><br><span class="line">        do_read();</span><br><span class="line">        p(readingCount);</span><br><span class="line">        readingCount --;</span><br><span class="line">        if (readingCount == 0)</span><br><span class="line">            v(mutex);</span><br><span class="line">        v(readingCount);</span><br><span class="line">    &#125;</span><br><span class="line">````</span><br></pre></td></tr></table></figure><p>void writer() {<br>    while(1) {<br>        p(mutex);<br>        do_write();<br>        v(mutex);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">####第二类读者和写者问题（写者优先）</span><br><span class="line">读者优先策略可能会导致写者饿死的情况出现，即写者可能永远不能得到资源，所以，我们可以采取写者优先策略。</span><br><span class="line">写者优先策略定义的读者写者之间关系如下：</span><br><span class="line">1. 读者之间可以同时读</span><br><span class="line">2. 写者和读者互斥</span><br><span class="line">3. 写者之间互斥</span><br><span class="line">4. 当读者和写者同时等待时，优先唤醒写者</span><br><span class="line"></span><br><span class="line">写者优先的策略可以引入一个 `writingCount` 记录写者个数，当 `writingCount` 等于 0 时，允许读者读，否则禁止读者读，此时，如果用 `mutex` 控制禁止读者读，可能会影响写者本身的写允许，所以引入一个信号量 `enable_entry` 控制允许读者读，同时读者之间需要修改 `writingCount`，所以引入 `enable_write` 控制写者对 `writingCount` 的互斥操作。如果出现读者在等待读的时候，后续出现一个写者，我们需要让写者优先被唤醒，所以需要一个信号量 `skip` 让读者进入等待，即每次只有一个读者可以进入。</span><br></pre></td></tr></table></figure></p><p>void reader() {<br>    while(1){<br>        p(skip)<br>        p(enable_entry);<br>        p(enable_read);<br>        readingCount ++;<br>        if (readingCount == 1)<br>            p(mutex);<br>        v(enable_read);<br>        v(enable_entry);<br>        v(skip)<br>        read();<br>        p(enable_read);<br>        readingCount –;<br>        if (readingCount == 0)<br>            v(mutex);<br>        v(enable_read);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>void writer(){<br>    while(1){<br>        p(enable_write);<br>        writingCount ++;<br>        if (writingCount == 1)<br>            p(enable_entry);<br>        v(enable_write);<br>        p(mutex);<br>        write();<br>        v(mutex);<br>        p(enable_write);<br>        writingCount –;<br>        if (writingCount == 0)<br>            v(enable_entry);<br>        v(enable_write);<br>    }<br>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###问题引入&lt;br&gt;在操作系统的多线程中，如何保证多个线程都对数据操作的一致性是我们需要考虑的问题。数据的不一致性主要体现在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可重复读 两次读到的数据不一致&lt;/li&gt;
&lt;li&gt;丢失修改 对数据进行操作之后，之后的数据又发生变化&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>貌似发现了一个好用的文档管理软件</title>
    <link href="http://yuanjngsong.github.io/2018/10/10/2018-10-10/"/>
    <id>http://yuanjngsong.github.io/2018/10/10/2018-10-10/</id>
    <published>2018-10-10T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现了一个好用的文档管理软件 <strong>mweb</strong>，类似于印象笔记但是由于是面向 markdown 用户，所以整体上比印象笔记要好用一点，可以用来做个人 wiki 管理。但由于印象笔记强大到无与伦比的网页插件 + 微信插件，主要的笔记整理还是由印象笔记完成。</p><p>研究 mweb 的时候发现导入外部文件夹进行同步，毫无疑问可以用来做个人博客的管理工具，这比之前用 Typora 做文件夹好用了不少。之前使用 Typora 的时候多了一个文件保存路径，这个只需要在对应的 category 新建文件即可。但 Typora 的实时预览真好用啊（真香</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;突然发现了一个好用的文档管理软件 &lt;strong&gt;mweb&lt;/strong&gt;，类似于印象笔记但是由于是面向 markdown 用户，所以整体上比印象笔记要好用一点，可以用来做个人 wiki 管理。但由于印象笔记强大到无与伦比的网页插件 + 微信插件，主要的笔记整理还是由印象
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何计算$\sqrt{x}$的大小</title>
    <link href="http://yuanjngsong.github.io/2018/08/09/%E8%AE%A1%E7%AE%97/"/>
    <id>http://yuanjngsong.github.io/2018/08/09/计算/</id>
    <published>2018-08-09T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>###如何计算$\sqrt{x}$ 的大小 </p><p>最近在看 SICP 这本书，里面讲到了一些最基本的计算，一个例子就是给定一个 $x$ ，如何去计算 $\sqrt{x}$ 的数值，这个问题可以从几个方面思考。</p><ol><li><p>不动点计算</p><p>不动点 (fixed point)，对于函数 $f$ 而言，不动点是指函数映射到自身的一个定点，满足$f(x) = x$ 的关系，所以对于函数 $y = \sqrt{x}$ 而言，有 $ y^2 = x$ 成立，从而有 $y = \frac{x}{y}$ 成立，所以，即是求 $f(y) = \frac{x}{y}$ 的不动点，此时 $x$ 为一个常数。这个不动点的值即为 $\sqrt{x}$ 的大小。<br>我们继续考虑不动点的问题，此时对于 $f(x) = \frac{a}{x}$ 而言，我们需要考虑的第一个问题是，这个函数是否有不动点，因为不是每个函数都存在不动点。对于这个问题，我们可以不用给出严格的证明，仅仅从图像可以看出，对于任何一个 $a &gt; 0$ 的函数 $f$ 必然满足 $\lim_{x \to 0} = + \infty$ 并有 $\lim_{x \to +\infty} = 0$，又这个函数处处连续，所以 $f$ 必然与 $g(x) = x$ 有交点，那么必然存在一个点$ A$ ，这个点是 $f$ 的不动点。</p><p>既然存在不动点，那么我们需要考虑的第二个问题是，如何计算这个不动点，有以下一个推论，这里不做证明。</p><p>对于序列 $x, f(x), f(f(x)), f(f(f(x)))$ ，反复计算我们可以逐步逼近这个不动点，在这里我们需要注意，这个 $x$ 的范围是否是无限的，还是说在一个 $\epsilon$ 的范围内，有如下的收敛。</p><p>但是如果仅仅根据这个公式，我们是无法计算出不动点的，不如手动迭代做验证。</p><p>对于一个猜测的数 $x_0$ ，我们可以计算下一个数 </p><p>$x_1 = \frac{a}{x_0}$ ，</p><p>$$\begin{align}x_2 &amp; =  \frac{a}{x_1} = \frac{a}{\frac{a}{x_0}}  = x_0\end{align}$$</p><p>  此时可以看到，出现了振荡现象，自然无法算出不动点的解。</p><p>我们可以对公式做一个变形，$y = \frac{x}{y}$ 可以写成 $ y = \frac{1}{2} * (\frac{x}{y} + y)$ 的形式，此时我们进行迭代计算，即可以算出不动点的位置了。</p><p>下面给出 <code>scheme</code> 实现</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f first-guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> v1 v2)) tolerance)</span><br><span class="line">    )</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ( (<span class="name">next</span> (<span class="name">f</span> guess)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough?</span> guess next)</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">try</span> next)</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  (<span class="name">try</span> first-guess)</span><br><span class="line">  )</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x) </span><br><span class="line">  (<span class="name">fixed-point</span>  (<span class="name"><span class="builtin-name">lambda</span></span> (y) (<span class="name">average</span> y (<span class="name"><span class="builtin-name">/</span></span> x y)) )</span><br><span class="line">                <span class="number">1.0</span>)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p>牛顿迭代法</p><p>牛顿迭代法 (Newton’s method) 是牛顿爵爷给出的一种方法，用来更好的寻找一个方程的根。</p><p>牛顿迭代法的步骤如下</p><ol><li>选择一个起始的点 $x_0$ </li><li>$x_1 = x_0 - \frac{f(x_0)} {f’(x_0)}$</li><li>判断一个范围，如果在这个可接受的范围内，即可使用</li></ol><p>简单的说牛顿迭代法遵循以下的迭代 $x_{n+1} = x_{n} - \frac{f(x_n)}{f’(x_n)}$</p><p>同时，牛顿迭代也是有其条件，在这里同样不赘述。</p><p>那么对于 $x^2 = a$ 而言，就是算 $g(x) = x^2 - a $ 的根。</p><p>$g’(x) = {2x}  $</p><p>那么可以根据这个式子，给出 <code>scheme</code> 的解答</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.000001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">newton-method</span> f guess)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span>( - v1 v2)) tolerance)</span><br><span class="line">    )</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next</span> </span><br><span class="line">           (<span class="name"><span class="builtin-name">-</span></span> guess </span><br><span class="line">              (\ (<span class="name">f</span> guess) ((<span class="name">derivate</span> f) guess))</span><br><span class="line">              )))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">cloese-enough?</span> guess )</span><br><span class="line">          next</span><br><span class="line">          (<span class="name">try</span> next)</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  (<span class="name">try</span> guess)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p>两点取中法</p><p>同牛顿迭代法思想一样，我们这次依然是计算$x^2  = a$ 的根，不过遵循的方式不同，</p><p>记 $g(x) = x^2 - a$ ，那么如果存在一个 $x_0, x_1$ 有 $g(x_0) &lt; 0 $ 并且 $g(x_1) &gt; 0$ 那么 $x_0, x_1$ 之间必然有一个根(中值定理)。所以我们可以根据这个法则进行迭代计算。</p><ol><li>有 $x_0, x_1$ 满足 $g(x_0) &lt; 0，g(x_1) &gt; 0$ </li><li>计算 $x_2 = \frac{x_0 + x_1} {2}$ 时$g(x_2)$的值，若 $g(x_2) &lt; 0$，则 x0 = x2，若 $g(x_2) &gt; 0$ 则 x1 = x2</li><li>计算 $x_0, x_1$之间的差距，如果小于一个阈值则选择相应的解 </li></ol><p>下面给出 <code>scheme</code>解法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.0000001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">two-point-iter</span> f a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough?</span> v1 v2)</span><br><span class="line">    ( &lt; (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> v1 v2)) tolerance )</span><br><span class="line">    )</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span>((<span class="name">mid</span> (<span class="name">average</span> a b)))</span><br><span class="line">       (<span class="name"><span class="builtin-name">cond</span></span> </span><br><span class="line">             ((<span class="name">close-enough?</span> a b) mid)</span><br><span class="line">             ((<span class="name"><span class="builtin-name">&gt;</span></span> (<span class="name">f</span> mid) <span class="number">0</span>) (<span class="name">two-point-iter</span> a mid))</span><br><span class="line">             (<span class="name"><span class="builtin-name">else</span></span> two-point-iter mid b)</span><br><span class="line">         )</span><br><span class="line">       )</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p><del>手动开根号法</del></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###如何计算$\sqrt{x}$ 的大小 &lt;/p&gt;
&lt;p&gt;最近在看 SICP 这本书，里面讲到了一些最基本的计算，一个例子就是给定一个 $x$ ，如何去计算 $\sqrt{x}$ 的数值，这个问题可以从几个方面思考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不动点计算&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HW1作业</title>
    <link href="http://yuanjngsong.github.io/2018/07/20/%E6%9D%8E%E5%AE%8F%E6%AF%85HW1/"/>
    <id>http://yuanjngsong.github.io/2018/07/20/李宏毅HW1/</id>
    <published>2018-07-20T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>本文是台湾大学李宏毅所授的机器学习 (2017 Fall) 的 HW1。<a href="https://ntumlta.github.io/2017fall-ml-hw1/" target="_blank" rel="noopener">相关链接</a></p><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="定义一个-function-set"><a href="#定义一个-function-set" class="headerlink" title="定义一个 function set"></a>定义一个 function set</h4><p>由于题目限制，这里必须是一个线性方程。</p><p>使用前 9 小时的污染物来预测第 10 小时的 pm2.5，所以定义方程为</p><p>$y_n = b + w^1_{n-1} <em>pm2.5_{n-1} + w^1_{n-2} </em> pm2.5_{n-2} + … + w^1_{n-9} * pm2.5_{n-9}+…$</p><p>可以写成矩阵形式</p><p>$$y_n = \left[ \begin{matrix}  1 &amp; pm2.5_{n-1} &amp; … &amp; pm2.5_{n-9} &amp; … &amp;\end{matrix}\right] \times \left[ \begin{matrix} b \w_{n-1} \… \ w_{n-9} \ …\end{matrix}\right] $$</p><h4 id="定义-Loss-function"><a href="#定义-Loss-function" class="headerlink" title="定义 Loss function"></a>定义 Loss function</h4><p>$L = \sum(y - (b + w_ix_i))^2$</p><h4 id="计算-Gradient-Descend"><a href="#计算-Gradient-Descend" class="headerlink" title="计算 Gradient Descend"></a>计算 Gradient Descend</h4><p>目的：找到一个 $\theta^{\star}$ 有 $\theta^{\star} = argminL(\theta)$</p><p>根据梯度下降，有</p><p>$$\theta_{1} = \theta_{0} - η \nabla L(\theta_0)$$</p><p>其中  $\eta$  为 learning rate</p><h4 id="引入-Adagrad-算法"><a href="#引入-Adagrad-算法" class="headerlink" title="引入 Adagrad 算法"></a>引入 Adagrad 算法</h4><p>$\theta_1 = \theta_0 - \frac{\eta}{\sigma_0} g_0$ ，其中 $g_0 = \nabla L(\theta_0)$  $\sigma_0 = \sqrt{g_0^2}$</p><p>$\theta_2 = \theta_1 - \frac{\eta}{\sigma_1}g_1$，其中 $g_1 = \nabla L (\theta_1)$    $\sigma_1 = \sqrt{\frac{1}{2} ({g_0}^2 + {g_1}^2)} $</p><p>进行迭代有</p><p>$\theta_n = \theta_{n-1} - \frac{\eta}{\sigma_{n-1}}g_{n-1}$ ，其中 $g_{n-1}  = \nabla L (\theta_{n-1})$  $\sigma_{n-1} = \sqrt{\frac{1}{n} \sum_{i=0}^{n-1} g_{i}^2}$</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure><h4 id="提取所有的污染物数据"><a href="#提取所有的污染物数据" class="headerlink" title="提取所有的污染物数据"></a>提取所有的污染物数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">18</span>):</span><br><span class="line">    data.append([])</span><br><span class="line"><span class="comment">#每一个 list 记录一种污染物 </span></span><br><span class="line">    </span><br><span class="line">n_row = <span class="number">0</span></span><br><span class="line">text = open(<span class="string">"./train.csv"</span>, <span class="string">'r'</span>, encoding=<span class="string">"big5"</span>)</span><br><span class="line">row = csv.reader(text, delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> row:</span><br><span class="line">    <span class="comment">#数据格式第一行没有row</span></span><br><span class="line">    <span class="keyword">if</span> n_row != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">27</span>):</span><br><span class="line">            <span class="keyword">if</span> r[i] != <span class="string">"NR"</span>:</span><br><span class="line">                data[(n_row - <span class="number">1</span>)%<span class="number">18</span>].append(float(r[i]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                data[(n_row - <span class="number">1</span>)%<span class="number">18</span>].append(float(<span class="number">0</span>))</span><br><span class="line">    n_row += <span class="number">1</span></span><br><span class="line">text.close()</span><br></pre></td></tr></table></figure><h4 id="转化为-x-y"><a href="#转化为-x-y" class="headerlink" title="转化为 (x, y)"></a>转化为 (x, y)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#x is train_x</span></span><br><span class="line"><span class="comment">#y is train_y</span></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="comment">#一共 20 * 24 = 480 条数据</span></span><br><span class="line"><span class="comment">#但每个月前9小时无法预测，所以是 480 - 9 条</span></span><br><span class="line"><span class="comment">#每个月要预测471条数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">480</span> - <span class="number">9</span>):</span><br><span class="line">        x.append([])</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">18</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                x[<span class="number">471</span>*i+j].append(data[t][<span class="number">480</span>*i+j+s])</span><br><span class="line">        y.append(data[<span class="number">9</span>][<span class="number">480</span>*i+j+<span class="number">9</span>])</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add bias</span></span><br><span class="line">x = np.concatenate((np.ones((x.shape[<span class="number">0</span>], <span class="number">1</span>)), x), axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>此时 x 是个5652行，162列的数组，每一行代表18种不同的数据，每种数据有9个小时的数据。</p><p>y 是个5652行，1列的数组，每一列代表对应的值。</p><h4 id="设定-learning-rate，迭代次数，和-w-初始值"><a href="#设定-learning-rate，迭代次数，和-w-初始值" class="headerlink" title="设定 learning rate，迭代次数，和 w 初始值"></a>设定 learning rate，迭代次数，和 w 初始值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = np.zeros(len(x[<span class="number">0</span>]))</span><br><span class="line">l_rate = <span class="number">10</span></span><br><span class="line">repeat = <span class="number">10000</span></span><br></pre></td></tr></table></figure><h4 id="进行迭代"><a href="#进行迭代" class="headerlink" title="进行迭代"></a>进行迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x_t = x.transpose()</span><br><span class="line">s_gra = np.zeros(len(x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(repeat):</span><br><span class="line">    hypo = np.dot(x,w)</span><br><span class="line">    loss = hypo - y</span><br><span class="line">    cost = np.sum(loss**<span class="number">2</span>) / len(x)</span><br><span class="line">    cost_a  = math.sqrt(cost)</span><br><span class="line">    gra = np.dot(x_t,loss)</span><br><span class="line">    s_gra += gra**<span class="number">2</span></span><br><span class="line">    ada = np.sqrt(s_gra)</span><br><span class="line">    w = w - l_rate * gra/ada</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'iteration: %d | Cost: %f  '</span> % ( i,cost_a))</span><br></pre></td></tr></table></figure><p>迭代完最后就可以得到 w 矩阵，进行预测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是台湾大学李宏毅所授的机器学习 (2017 Fall) 的 HW1。&lt;a href=&quot;https://ntumlta.github.io/2017fall-ml-hw1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>详解自动跳一跳源码</title>
    <link href="http://yuanjngsong.github.io/2018/03/28/%E8%AF%A6%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%B7%B3%E4%B8%80%E8%B7%B3%E6%BA%90%E7%A0%81/"/>
    <id>http://yuanjngsong.github.io/2018/03/28/详解自动跳一跳源码/</id>
    <published>2018-03-28T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章带你进一步剖析如何利用python实现电脑端的自动跳一跳。<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">项目地址在这</a> 可以找到源码并学习。</p><p>这个项目是微信刚出跳一跳的时候，是项目作者自己开发并开源的，最初的版本并没有现在看到的这么成熟，但是在短短的一周时间内刷到了1k的star，功能也从最开始不支持iOS，只能在电脑端点击两点距离进化成了跨平台，自动跳跃。这篇文章并不会纠结于ABD的使用和修改签名，仅仅是从作者的思路出发，在默认已有截图的情况下，分析如何做到识别棋子并跳跃的过程。</p><p>整体思路：利用电脑端的辅助工具，截取当前的手机截图，计算出截图中的棋子位置和下一步的位置，计算几何距离，模拟按压进行跳跃。</p><p>核心思路：找到棋子的位置，识别下一步的位置，模拟按压时间</p><a id="more"></a><p>找到棋子的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数是图像</span></span><br><span class="line">piece_x_sum = piece_x_c = piece_y_max = <span class="number">0</span></span><br><span class="line">board_x = board_y = <span class="number">0</span></span><br><span class="line">scan_x_border = int(w/<span class="number">8</span>)</span><br><span class="line">scan_start_y = <span class="number">0</span></span><br><span class="line">im_pixel = im.load()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(under_game_score_y, h, <span class="number">50</span>): <span class="comment">#under_game_score_y 是分数所在的坐标</span></span><br><span class="line">        last_pixel = im_pixel[<span class="number">0</span>, i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, w):</span><br><span class="line">            pixel = im_pixel[j, i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 不是纯色的线，则记录scan_start_y的值，准备跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> pixel != last_pixel:</span><br><span class="line">                scan_start_y = i - <span class="number">50</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> scan_start_y:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"scan_start_y: "</span>, scan_start_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从 scan_start_y 开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过 2/3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(scan_start_y, int(h * <span class="number">2</span> / <span class="number">3</span>)):</span><br><span class="line">        <span class="comment"># 横坐标方面也减少了一部分扫描开销</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(scan_x_border, w - scan_x_border):</span><br><span class="line">            pixel = im_pixel[j, i]</span><br><span class="line">            <span class="comment"># 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜</span></span><br><span class="line">            <span class="comment"># 色这样应该 OK，暂时不提出来</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">50</span> &lt; pixel[<span class="number">0</span>] &lt; <span class="number">60</span>) \</span><br><span class="line">                    <span class="keyword">and</span> (<span class="number">53</span> &lt; pixel[<span class="number">1</span>] &lt; <span class="number">63</span>) \</span><br><span class="line">                    <span class="keyword">and</span> (<span class="number">95</span> &lt; pixel[<span class="number">2</span>] &lt; <span class="number">110</span>):</span><br><span class="line">                piece_x_sum += j</span><br><span class="line">                piece_x_c += <span class="number">1</span></span><br><span class="line">                piece_y_max = max(i, piece_y_max)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> all((piece_x_sum, piece_x_c)):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    piece_x = piece_x_sum / piece_x_c</span><br><span class="line">    piece_y = piece_y_max - piece_base_height_1_2  <span class="comment"># 上移棋子底盘高度的一半</span></span><br></pre></td></tr></table></figure><p>这里的思路就是将从显示分数的高度开始，向下扫描，间隔50个像素，每到一行，就开始横向扫描，以最左边的点为基准像素，横向比较，如果不是纯色的线，则记录 <code>scan_start_y</code> 的y轴坐标，此时减50个像素应该是避免出现bug</p><p>再拿到<code>scan_start_y</code>之后，开始继续向下扫描，确定棋子的精确位置，至于为什么要分两次扫描，大概是因为减少开销，在确定<code>scan_start_y</code> 之前，所有的扫描只是和之前的像素值简单的对比，而在<code>scan_start_y</code>之后的扫描，每次都要比较像素的RGB值，分两次扫描可以减少一些不必要的比较。</p><p>在这里，近似的估计了棋子所在的高度不超过 $\frac{2}{3}h$ ，然后估计棋子所在的宽度区间是除去$\frac{border}{8}$ 的中间部分，然后开始逐行，扫描像素，如果像素的RGB值是在(50, 53, 95) 和 (60, 63, 110)这个范围内，那么记录他的横轴坐标，最后通过计算平均值，得到棋子的横坐标。棋子纵坐标是选取符合RGB条件的纵轴的最大值然后减去棋子基座的一般，即尽可能的低。</p><p>这里有一个 <code>all((piece_x_sum, piece_x_c))</code> 是一个pythonic的写法，用来检查<code>piece_x_sum</code> 和 <code>piece_x_c</code> 是否为0。</p><p>然后是找到下一个需要跳的位点，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">board_x = board_y = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(int(h / <span class="number">3</span>), int(h * <span class="number">2</span> / <span class="number">3</span>)):</span><br><span class="line">       last_pixel = im_pixel[<span class="number">0</span>, i]</span><br><span class="line">       <span class="keyword">if</span> board_x <span class="keyword">or</span> board_y:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       board_x_sum = <span class="number">0</span></span><br><span class="line">       board_x_c = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">           pixel = im_pixel[j, i]</span><br><span class="line">           <span class="comment"># 修掉脑袋比下一个小格子还高的情况的 bug</span></span><br><span class="line">           <span class="keyword">if</span> abs(j - piece_x) &lt; piece_body_width:</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># 修掉圆顶的时候一条线导致的小 bug，这个颜色判断应该 OK，暂时不提出来</span></span><br><span class="line">           <span class="keyword">if</span> abs(pixel[<span class="number">0</span>] - last_pixel[<span class="number">0</span>]) \</span><br><span class="line">                   + abs(pixel[<span class="number">1</span>] - last_pixel[<span class="number">1</span>]) \</span><br><span class="line">                   + abs(pixel[<span class="number">2</span>] - last_pixel[<span class="number">2</span>]) &gt; <span class="number">10</span>:</span><br><span class="line">               board_x_sum += j</span><br><span class="line">               board_x_c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> board_x_sum:</span><br><span class="line">           board_x = board_x_sum / board_x_c</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 按实际的角度来算，找到接近下一个 board 中心的坐标 这里的角度应该</span></span><br><span class="line">   <span class="comment"># 是 30°,值应该是 tan 30°, math.sqrt(3) / 3</span></span><br><span class="line">   board_y = piece_y - abs(board_x - piece_x) * math.sqrt(<span class="number">3</span>) / <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> all((board_x, board_y)):</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里先是估计了下一个的位点所在的位置大概在 $\frac{h}{3} \sim \frac{2h}{3} $ 之间，类似的，从最左边的像素开始对比，先找到下一个位点的横坐标然后利用棋子中心到下一个位点角度为30度的几何关系，计算出下一个位点的纵坐标。</p><p>这里应该避免一种情况是可能棋子和下一个板子距离过近，出现先扫描到棋子头部的情况，所以用 <code>abs(j - piece_x) &lt; piece_body_width</code> 来避免。</p><p>到这里我们就可以计算出棋子中心的坐标和下一个位点的坐标了，利用这两个点的坐标，我们可以计算出两点的距离，然后根据比例关系，计算出模拟按压的时间，实现自动跳一跳了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章带你进一步剖析如何利用python实现电脑端的自动跳一跳。&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址在这&lt;/a&gt; 可以找到源码并学习。&lt;/p&gt;
&lt;p&gt;这个项目是微信刚出跳一跳的时候，是项目作者自己开发并开源的，最初的版本并没有现在看到的这么成熟，但是在短短的一周时间内刷到了1k的star，功能也从最开始不支持iOS，只能在电脑端点击两点距离进化成了跨平台，自动跳跃。这篇文章并不会纠结于ABD的使用和修改签名，仅仅是从作者的思路出发，在默认已有截图的情况下，分析如何做到识别棋子并跳跃的过程。&lt;/p&gt;
&lt;p&gt;整体思路：利用电脑端的辅助工具，截取当前的手机截图，计算出截图中的棋子位置和下一步的位置，计算几何距离，模拟按压进行跳跃。&lt;/p&gt;
&lt;p&gt;核心思路：找到棋子的位置，识别下一步的位置，模拟按压时间&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件记录</title>
    <link href="http://yuanjngsong.github.io/2018/03/23/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    <id>http://yuanjngsong.github.io/2018/03/23/软件记录/</id>
    <published>2018-03-23T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>本帖长期会更新，旨在为可能换电脑后快速找到自己经常使用的软件，同时分享一些顺手的软件。(欢迎大家在github上提issue</p><p>效率类：</p><ol><li>幕布  一个用来整理笔记的地方</li><li>chrome 装机必备</li><li>wechat  国民必备</li><li>迅雷 macOS上的迅雷真是良心</li><li>Adobe 系列选装 </li><li>Evernote 印象笔记</li><li>Mounty 完美解决u盘格式问题</li><li>Pap.er 给你一个好的桌面</li><li>smcFanControl 可以监控你的电脑温度，同时设定模式</li><li>TeamViewer <del>多次远程操作妹子电脑</del></li><li>The Unarchiver 打开一些命令行无能的压缩包</li><li>Typora markdown<strong>神器</strong></li><li>Pin 一个可以记录历史的粘贴板</li><li>KarabinerElements 改键大法好</li><li>IINA 符合mac设计的播放器</li><li>iCHM 看chm文件的</li><li>Dropbox 初始2gb免费空间</li><li>Magnet 快速改变软件所占屏幕大小</li></ol><p>Pro：</p><ol><li>BurpSuite 抓包必备</li><li>iTerm2 比原生termianl不知道高到哪里去了</li><li>IDEA</li><li>Postman 一个发包神器</li><li>PyCharm</li><li>Sequel Pro 一个可视化的数据库软件</li><li>ShadowsocksX-NG</li><li>Visual Studio Code 微软教你做编辑器系列</li><li>Wireshark 网络抓包必备</li><li>Xcode 必备</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本帖长期会更新，旨在为可能换电脑后快速找到自己经常使用的软件，同时分享一些顺手的软件。(欢迎大家在github上提issue&lt;/p&gt;
&lt;p&gt;效率类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;幕布  一个用来整理笔记的地方&lt;/li&gt;
&lt;li&gt;chrome 装机必备&lt;/li&gt;
&lt;li&gt;wec
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求解数独</title>
    <link href="http://yuanjngsong.github.io/2018/03/11/%E6%B1%82%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>http://yuanjngsong.github.io/2018/03/11/求解数独/</id>
    <published>2018-03-11T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>​    突发奇想，想用计算机求解一下数独。发现似乎并不难写，一个DFS+回溯即可求出正确答案，但还是写了好半天/手动捂脸，在这里记录一下具体操作</p><p>​    数独我们可以用一个9*9的二维矩阵存，因为是回溯法，我们还需要一个标识是否求解完成的状态位<code>finished</code>，基本思路是从<code>sudoku[0][0]</code>开始检查是否为0，如果为0，即可以开始尝试填数字，如果不为0，则向左继续搜索，基本规则尽可能的先填满一行，然后再填另一行 ，直到填满所有的空位，此时搜索结束。</p><p>​    基本思路很简单，但是最开始一直错的原因是并没有使用标识位，导致最后的搜索完没有正确退出。然后gg。一个需要注意的地方是，如果填好一个数字后，填下一个数字时，所有数字均不可行，那么，在回退时，应置为0。</p><p>​    给出关键代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">9</span>) &#123;</span><br><span class="line">        finished = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"%d "</span>,sudoku[i][j]);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (sudoku[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(check(row, col, i) &amp;&amp; checkRow(row, col, i) &amp;&amp; checkCol(row, col, i)) &#123;</span><br><span class="line">              sudoku[row][col] = i;</span><br><span class="line">                <span class="keyword">if</span> (col + <span class="number">1</span> &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                    dfs(row, col + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dfs(row+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">if</span> (finished) &#123; <span class="comment">//如果搜索完成则直接返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                  sudoku[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(col + <span class="number">1</span> &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            dfs(row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span>(finished) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里还有一个关键是如何判断填的数字符合要求，其中的行判断和列判断都很简单，如何判断一个九宫格呢？我使用的方法是，先将要填的数独可以分为3*3的部分，九个九宫格分别对应不同的部分，这样，知道需要判断的格子坐标，就知道是那个九宫格了。例如<code>sudoku[i][j]</code>这个坐标，对应的是第$\frac{i}{3},\frac{j}{3}$个九宫格 ，然后整个九宫格就可以用以下代码遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rowTh = row / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> colTh = col / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> Row, Col;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         Row = rowTh * <span class="number">3</span> + i;</span><br><span class="line">          Col= colTh * <span class="number">3</span> + j;</span><br><span class="line">          <span class="keyword">if</span> (Row == row &amp;&amp; Col == col) &#123; <span class="comment">//扫描到需要判断的格子，不判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sudoku[row][col] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    突发奇想，想用计算机求解一下数独。发现似乎并不难写，一个DFS+回溯即可求出正确答案，但还是写了好半天/手动捂脸，在这里记录一下具体操作&lt;/p&gt;
&lt;p&gt;​    数独我们可以用一个9*9的二维矩阵存，因为是回溯法，我们还需要一个标识是否求解完成的状态位&lt;code&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算递归表达式复杂度</title>
    <link href="http://yuanjngsong.github.io/2018/03/11/%E8%AE%A1%E7%AE%97%E9%80%92%E5%BD%92%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yuanjngsong.github.io/2018/03/11/计算递归表达式复杂度/</id>
    <published>2018-03-11T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人理解递推，神理解递归   </p><p>​                                    来自“这话我没说过的”的鲁迅</p></blockquote><p>​    递归在程序设计中，有着非常重要的地位，有了递归，我们可以更方便的表达程序逻辑，递归的好处在于其便于大家理解，坏处是计算递归的算法复杂度可能是一件复杂的事，同时，如何写出正确的递归往往需要考虑很多方面。这里，根据MIT的6.046J <em>Introduction to Algorithms</em> 相关讲义和 <em>算法导论</em> ，谈谈如何求解一个递归表达式的算法复杂度。</p><ol><li><p>xjb猜法（最常见的方法）</p><p>对于一个递归方程，我们可以根据经验，套路，或者其他因素，猜一个可能的算法复杂度，然后证明这个复杂度。</p><ul><li>猜一个算法复杂度可能的形式</li><li>给出证明 通常是归纳法</li><li>求解常数</li></ul><p>给一个栗子</p><p>已知递归方程$T(n) = 4 T(\frac{n}{2}) + n $ , 求解其算法复杂度</p><p>Sovle:</p><pre><code>1. 我们不妨断定$T(1) = \theta(1)$ 2. 根据经验，算法复杂度可能是$O(n^3)$, (xjb猜)  3. 不妨假设当$k &lt; n$时有$T(k) \le ck^3$ （这个c是参变量）  4. 证明$T(n)\lt cn^3$</code></pre><p>这就是一个常见的一个套路只要遵循这个套路，最后给出证明，即可，应用的数学原理是数学归纳法</p><p>现在给出第四步的证明</p><p>$T(n) = 4T(\frac{n}{2}) + n$</p><p>根据3的假设有</p><p>$$T(n) \le 4c(\frac{n}{2})^3 + n$$</p><p>整理得</p><p>$$T(n) = cn^3 - ((\frac{c}{2})n^3 -n )$$</p><p>写成这个形式也是必须的，因为我们目标是证明$T(n)\lt cn^3$</p><p>此时，显然可以找到一个$c$与$n$有$\frac{c}{2} n^3 \lt n$成立，即有$T(n) \lt cn^3$</p><p>则得证</p><p>但是，这个方法有一个问题，即xjb猜的话，没有经验的人可能会一脸蒙b，容易猜的过大或过小。</p><p>同时，这个思想不能总得到一个较为准确的上界，上面递归公式的我们猜的上界过大，我们不能证明我们猜的上界即为比较好的上界，这里的好指的是可以更精准的描述这个递归公式，我们可以继续猜测这个递归公式可能有一个更小的上界 $T(n) = O(n^2)$, 继续尝试证明。</p><p>类似地，与之前的套路类似，假设当$k\lt n$有 $T(k) \le ck^2$，尝试证明 $T(n) \le cn^2$ </p><p>$T(n) = 4 T(\frac{n}{2}) + n $</p><p>带入假设，得</p><p>$T(n) \le 4cn^2 + n$</p><p>这次我们不能得到 $T(n) \lt cn^2$</p><p>那么，我们能否说明$T(n)$的复杂度比$n^2$大呢？</p><p>显然不能！这里我们利用猜测仅仅证明出$T(n) &lt; 4cn^2 + n$，并没有证明$T(n)&gt;n^2$，不能说明$T(n) &gt; n^2$ ，这就是猜测法的缺陷，如何我们错误的构造了复杂度，那么很有可能无法证明正确的结果。此时，我们继续猜测一个可能的上界 $T(n) = O(c_1k^2-c_2k)$，继续尝试证明。</p><p>假设当$k \lt n $有 $T(k) &lt; c_1k^2-c_2k$，尝试继续证明$T(n) &lt; c_1n^2-c_2n$</p><p>$T(n) = 4T(\frac{n}{2}) + n$</p><p>带入假设，得</p><p>$T(n) \le 4(c_1(\frac{n}{2})^2 - c_2(\frac{n}{2})) + n$</p><p>整理得</p><p>$T(n) = c_1n^2-c_2n-(c_2n-n)$</p><p>容易看出，当 $c_2 \gt 1$ 有 $T(n) \le c_1n^2 - c_2n$</p><p>所以可以证明 $T(n)=O(c_1n^2-c_2n)$，又根据放缩有 $T(n) = O(n^2)$</p><p>所以，这个猜测法存在较大的问题，没有很好的普适性。</p></li><li><p>求解递归树</p><p>可以把递归方程式写成其他的形式，进而求解</p><p>已知$T(n) = T(\frac{n}{4}) + T(\frac{n}{2}) + n^2$</p><p>$T(\frac{n}{4}) = T(\frac{n}{16}) + T(\frac{n}{8})+ (\frac{n}{4})^2$</p><p>$T(\frac{n}{2}) = T(\frac{n}{8}) + T(\frac{n}{4}) + (\frac{n}{2})^2$</p><p>$\ldots$</p><p>$T(n) = n^2 (1 + \frac{5}{16} + (\frac{5}{16})^2 ++ (\frac{5}{16})^3+ \cdots )$</p><p>$T(n) = \Theta(n^2)$</p></li><li><p>套公式法</p><p>适用于符合下面形式的式子</p><p>$T(n) = aT(\frac{n}{b}) + f(n)$     $a \ge 1 \&amp; b\gt 1 \&amp; f(n) \gt 0$</p><p>然后比较$f(n)$ 与 $n^{log_ba}$ 的大小</p><ul><li>当存在一个$\epsilon \gt 0$ 有 $f(n)  = O(n^{log_ba-\epsilon})$ 即意味着$f(n)$在多项式时间内增长的比$n^{log_ba}$要慢，所以，$T(n) = \Theta(n^{log_ba})$</li><li>若 $f(n) = \Theta(n^{log_ba})$ 有$T(n) = \Theta(n^{log_ba} \lg n)$</li><li>若有一个常数 $c &lt; 1$及 所有的 $n\ge b, af(\frac{n}{b}） \le cf(n) $ 则 $T(n) = \Theta(f(n))$</li></ul><p>证明方式和第二种类似</p><p>$T(\frac{n}{b}) = aT(\frac{n}{b^2}) + f(\frac{n}{b})$</p><p>根据迭代，我们可以给出一个精确的数学公式描述总代价</p><p>$\sum_{i=0}^{log_bn-1}a^if(\frac{n}{b^i}) $</p><p>即现在的问题转换成了如何去求这个求和公式</p><ul><li><p>在第一种情况下，有 $f(n) = O(n^{log_ba-\epsilon})$ ，即有 $f(\frac{n}{b^i}) = O((\frac{n}{b^i}) ^ {log_ba-\epsilon})$ ，所以原级数公式可以代换为 $\sum_{i=0}^{log_b n -1} a^i O((\frac{n}{b^i}) ^ {log_ba-\epsilon})$  即为 $O(\sum_{i=0}^{log_b n -1} a^i (\frac{n}{b^i}) ^ {log_ba-\epsilon})$ 所以问题继续变成求解这个级数。</p><p>$\sum_{i=0}^{log_b n -1} a^i (\frac{n}{b^i}) ^ {log_ba-\epsilon} = n^{log_b a-\epsilon} \sum_{i=0}^{log_b n -1}(\frac{ab^\epsilon}{b^{log_ba}})^i $  （在这个级数中 变量是 $i$ ，所以可以将 $n^{log_b a - \epsilon}$ 提出化简。</p><p>有指数和对数定义，可化简分母，得到</p><p> $\sum_{i=0}^{log_b n -1}(\frac{ab^\epsilon}{b^{log_ba}})^i = \sum_{i=0}^{log_b n -1}(b^\epsilon)^i$ </p><p>由级数求和公式得</p><p>$\sum_{i=0}^{log_b n -1}(b^\epsilon)^i = \frac{b^{\epsilon log_b n - 1}}{b^{\epsilon} - 1} = \frac{n^{\epsilon} - 1}{b ^{\epsilon} - 1}$</p><p>又 $b$ 与$\epsilon$ 都是常数，所以$\frac{n^{\epsilon} - 1}{b ^{\epsilon} - 1}  = O(n^{\epsilon}) $ </p><p>所以可得$n^{log_b a-\epsilon} O(n^\epsilon) = O(n^{log_b a})$</p></li><li><p>在第二种情况下，有 $f(n) = \Theta(n^{log_b a})$，即有$f(\frac{n}{b^i}) = \Theta((\frac{n}{b^i}) ^ {log_ba})$ ，所以原级数公式可以代换成$\sum_{i=0}^{log_b n -1} a^i \Theta((\frac{n}{b^i}) ^ {log_ba})$ 即为$\Theta(\sum_{i=0}^{log_b n -1} a^i (\frac{n}{b^i}) ^ {log_ba})$ 所以即求解这个级数。</p><p>$\sum_{i=0}^{log_b n -1} a^i (\frac{n}{b^i}) ^ {log_ba} = n ^{log_b a} \sum_{i=0} ^{log_ b n - 1} \frac{a^{i}}{a^i} = n ^{log_b a}\sum_{i=0}^{log_b n-1} 1= n ^{log_b a}log _b n $  </p><p>所以第二种情况得证。</p></li><li><p>第三种情况，假设对常数 $c &lt; 1$ 和所有的 $n \ge b$ 有$ a f(\frac{n}{b}) \le c f(n) $ ，有 $f(\frac{n}{b}) \le \frac{c}{a} f(n)$ ，所以 $i$ 次迭代后，有 $f(\frac{n}{b^i}) \le (\frac{c}{a})^i f(n)$ 即 $a^if(\frac{n}{b^i}) \le c^if(n)$</p><p>所以，可以使用放缩求出结果</p><p>$\sum_{i=0}^{log_bn-1}a^if(\frac{n}{b^i}) \le \sum_{i=0}^{log_bn-1} c^i f(n) \le f(n) \sum_{i=o} ^{\infty}c^i = f(n)(\frac{1}{1-c} )= O(f(n))$   </p></li></ul><p>之上仅仅证明了 $n$ 是 $b$ 的整数幂时的情况。但类似的，如果 $n$ 不是 $b$ 的整数次幂时，仅仅改变了求和级数的上界，这里不给出详细的证明。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;人理解递推，神理解递归   &lt;/p&gt;
&lt;p&gt;​                                    来自“这话我没说过的”的鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    递归在程序设计中，有着非常重要的地位，有了递归，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typora</title>
    <link href="http://yuanjngsong.github.io/2017/02/13/1.21/"/>
    <id>http://yuanjngsong.github.io/2017/02/13/1.21/</id>
    <published>2017-02-13T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>我学会Typora竟然是给高三的孩子写报志愿流程？？？ 明天就要给女票注册博客了 可我还不是太会 怎么办 手动小纠结</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我学会Typora竟然是给高三的孩子写报志愿流程？？？ 明天就要给女票注册博客了 可我还不是太会 怎么办 手动小纠结&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搞事</title>
    <link href="http://yuanjngsong.github.io/2017/02/12/1.18/"/>
    <id>http://yuanjngsong.github.io/2017/02/12/1.18/</id>
    <published>2017-02-12T00:00:00.000Z</published>
    <updated>2018-11-12T11:43:10.993Z</updated>
    
    <content type="html"><![CDATA[<p>接了铮爷一个大事情，不过编书这种事情真的要好好斟酌啊， 我可能过了一个假寒假！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接了铮爷一个大事情，不过编书这种事情真的要好好斟酌啊， 我可能过了一个假寒假！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
